<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>WebRTC Remote Desktop</title>
    <style>
        html, body {
            margin: 0; padding: 0; height: 100%; overflow: hidden;
            background: #111; color: #eee; font-family: system-ui, sans-serif;
        }
        #topbar {
            position: fixed; top: 10px; left: 10px; right: 10px; z-index: 10;
            display: flex; gap: 10px; align-items: stretch;
        }
        textarea { width: 50%; height: 110px; background: #000; color: #0f0; padding: 8px; }
        button { padding: 8px 12px; }
        #screen { display: block; width: 100vw; height: 100vh; }
        #overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; }
    </style>
</head>
<body>
    <div id="topbar"><span>Connectingâ€¦</span></div>
    <canvas id="screen"></canvas>
    <div id="overlay"></div>

    <script>
        // Canvas setup
        const screen = document.getElementById('screen');
        const ctx = screen.getContext('2d');
        let scale = 1, offsetX = 0, offsetY = 0, serverWidth = 1, serverHeight = 1, lastUpdate = null;
        function resizeCanvas() {
            screen.width = window.innerWidth; screen.height = window.innerHeight; draw(lastUpdate);
        }
        window.addEventListener('resize', resizeCanvas); resizeCanvas();

        function drawCursor(x, y) {
            ctx.fillStyle = 'white'; ctx.strokeStyle = 'black'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + 14); ctx.lineTo(x + 10, y + 10); ctx.closePath();
            ctx.fill(); ctx.stroke();
        }
        function draw(update) {
            if (!update || !update.image) return;
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, screen.width, screen.height);
                serverWidth = img.naturalWidth; serverHeight = img.naturalHeight;
                scale = Math.min(screen.width / serverWidth, screen.height / serverHeight);
                const newW = serverWidth * scale, newH = serverHeight * scale;
                offsetX = (screen.width - newW) / 2; offsetY = (screen.height - newH) / 2;
                ctx.drawImage(img, offsetX, offsetY, newW, newH);
                const mx = offsetX + (update.mouseX * scale), my = offsetY + (update.mouseY * scale);
                drawCursor(mx, my);
            };
            img.src = 'data:image/jpeg;base64,' + update.image;
        }

        // WebRTC auto signaling via /signal
    let pc = null, dcInput = null, dcFrames = null;
    // Chunk reassembly buffers
    let currentFrame = null; // { id, chunks, received, parts: [], mouseX, mouseY }
        function createPC() {
            pc = new RTCPeerConnection({ iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }] });
            // Data channels: we create both so Windows peer can receive and handle accordingly
            dcInput = pc.createDataChannel('input');
            dcFrames = pc.createDataChannel('frames');

            dcFrames.onopen = () => console.log('frames dc open');
            dcFrames.onclose = () => console.log('frames dc close');
            dcFrames.onmessage = (e) => {
                try {
                    const msg = JSON.parse(e.data);
                    if (msg && msg.type === 'frameMeta') {
                        // Start a new frame buffer
                        currentFrame = {
                            id: msg.id,
                            chunks: msg.chunks,
                            received: 0,
                            parts: new Array(msg.chunks),
                            mouseX: msg.mouseX,
                            mouseY: msg.mouseY,
                        };
                    } else if (msg && msg.type === 'frameChunk' && currentFrame && msg.id === currentFrame.id) {
                        if (msg.index >= 0 && msg.index < currentFrame.chunks) {
                            currentFrame.parts[msg.index] = msg.data;
                            currentFrame.received++;
                            if (currentFrame.received === currentFrame.chunks) {
                                // Assemble and draw
                                const image = currentFrame.parts.join('');
                                lastUpdate = { image, mouseX: currentFrame.mouseX, mouseY: currentFrame.mouseY };
                                draw(lastUpdate);
                                currentFrame = null;
                            }
                        }
                    } else if (msg && msg.image) {
                        // Backward compatibility (single payload)
                        lastUpdate = msg; draw(lastUpdate);
                    }
                } catch (err) {
                    // Non-JSON or parse error; ignore silently
                }
            };
            pc.onicecandidate = () => { /* no-op: we wait for gathering to complete */ };
        }

        function waitIceGathering(pc) {
            if (pc.iceGatheringState === 'complete') return Promise.resolve();
            return new Promise((resolve) => {
                function check() {
                    if (pc.iceGatheringState === 'complete') {
                        pc.removeEventListener('icegatheringstatechange', check); resolve();
                    }
                }
                pc.addEventListener('icegatheringstatechange', check);
            });
        }

        async function start() {
            if (!pc) createPC();
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            await waitIceGathering(pc);
            const sdp = pc.localDescription;
            const res = await fetch('/signal', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ offer: sdp })
            });
            if (!res.ok) throw new Error('Signaling failed: ' + res.status);
            const answer = await res.json();
            await pc.setRemoteDescription(answer);
            document.getElementById('topbar').innerHTML = '<span>Connected</span>';
        }
        start().catch(err => {
            console.error(err);
            document.getElementById('topbar').innerHTML = '<span style="color:#f66">Failed to connect: '+String(err)+'</span>';
        });

        // Input events -> send JSON over dcInput
        function sendEvent(ev) {
            if (!dcInput || dcInput.readyState !== 'open') return;
            if (ev.type === 'contextmenu' || (ev.type === 'keydown' && (ev.ctrlKey || ev.metaKey))) ev.preventDefault();
            const data = { type: ev.type, key: ev.key, keyCode: ev.keyCode, modifiers: [], deltaY: ev.deltaY };
            if (ev.shiftKey) data.modifiers.push('shift');
            if (ev.ctrlKey) data.modifiers.push('ctrl');
            if (ev.altKey) data.modifiers.push('alt');
            if (ev.type.startsWith('mouse') || ev.type === 'wheel' || ev.type === 'contextmenu') {
                if (ev.clientX < offsetX || ev.clientX > offsetX + (serverWidth * scale) || ev.clientY < offsetY || ev.clientY > offsetY + (serverHeight * scale)) return;
                data.x = Math.round((ev.clientX - offsetX) / scale);
                data.y = Math.round((ev.clientY - offsetY) / scale);
            }
            if (ev.type === 'mousedown' || ev.type === 'mouseup' || ev.type === 'contextmenu') {
                data.button = ev.button === 2 ? 'right' : ev.button === 1 ? 'center' : 'left';
            }
            try { dcInput.send(JSON.stringify(data)); } catch {}
        }
        window.addEventListener('paste', (e) => {
            if (!dcInput || dcInput.readyState !== 'open') return; e.preventDefault();
            const text = e.clipboardData.getData('text/plain');
            dcInput.send(JSON.stringify({ type: 'paste', clipboardText: text }));
        });
        screen.addEventListener('mousemove', sendEvent);
        screen.addEventListener('mousedown', sendEvent);
        screen.addEventListener('mouseup', sendEvent);
        screen.addEventListener('contextmenu', sendEvent);
        screen.addEventListener('wheel', sendEvent);
        window.addEventListener('keydown', sendEvent);
        window.addEventListener('keyup', sendEvent);
    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>WebRTC Remote Desktop (manual SDP)</title>
    <style>
        html, body {
            margin: 0; padding: 0; height: 100%; overflow: hidden;
            background: #111; color: #eee; font-family: system-ui, sans-serif;
        }
        #topbar {
            position: fixed; top: 10px; left: 10px; right: 10px; z-index: 10;
            display: flex; gap: 10px; align-items: stretch;
        }
        textarea { width: 50%; height: 110px; background: #000; color: #0f0; padding: 8px; }
        button { padding: 8px 12px; }
        #screen { display: block; width: 100vw; height: 100vh; }
        #overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; }
    </style>
</head>
<body>
    <div id="topbar">
        <button id="createOffer">1) Create Offer</button>
        <textarea id="localOffer" placeholder="Local Offer (base64)"></textarea>
        <textarea id="remoteAnswer" placeholder="Paste Answer (base64) and click Set"></textarea>
        <button id="setAnswer">2) Set Answer</button>
    </div>
    <canvas id="screen"></canvas>
    <div id="overlay"></div>

    <script>
        // Canvas setup
        const screen = document.getElementById('screen');
        const ctx = screen.getContext('2d');
        let scale = 1, offsetX = 0, offsetY = 0, serverWidth = 1, serverHeight = 1, lastUpdate = null;
        function resizeCanvas() {
            screen.width = window.innerWidth; screen.height = window.innerHeight; draw(lastUpdate);
        }
        window.addEventListener('resize', resizeCanvas); resizeCanvas();

        function drawCursor(x, y) {
            ctx.fillStyle = 'white'; ctx.strokeStyle = 'black'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + 14); ctx.lineTo(x + 10, y + 10); ctx.closePath();
            ctx.fill(); ctx.stroke();
        }
        function draw(update) {
            if (!update || !update.image) return;
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, screen.width, screen.height);
                serverWidth = img.naturalWidth; serverHeight = img.naturalHeight;
                scale = Math.min(screen.width / serverWidth, screen.height / serverHeight);
                const newW = serverWidth * scale, newH = serverHeight * scale;
                offsetX = (screen.width - newW) / 2; offsetY = (screen.height - newH) / 2;
                ctx.drawImage(img, offsetX, offsetY, newW, newH);
                const mx = offsetX + (update.mouseX * scale), my = offsetY + (update.mouseY * scale);
                drawCursor(mx, my);
            };
            img.src = 'data:image/jpeg;base64,' + update.image;
        }

        // WebRTC manual signaling
        let pc = null, dcInput = null, dcFrames = null;
        function createPC() {
            pc = new RTCPeerConnection({ iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }] });
            // Data channels: we create both so Windows peer can receive and handle accordingly
            dcInput = pc.createDataChannel('input');
            dcFrames = pc.createDataChannel('frames');

            dcFrames.onmessage = (e) => {
                try { lastUpdate = JSON.parse(e.data); draw(lastUpdate); } catch {}
            };
            pc.onicecandidate = () => { /* no-op: we wait for gathering to complete */ };
        }

        async function createOffer() {
            if (!pc) createPC();
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            await waitIceGathering(pc);
            const sdp = pc.localDescription;
            const b64 = btoa(JSON.stringify(sdp));
            document.getElementById('localOffer').value = b64;
        }
        async function setAnswer() {
            const b64 = document.getElementById('remoteAnswer').value.trim();
            const json = JSON.parse(atob(b64));
            await pc.setRemoteDescription(json);
        }
        function waitIceGathering(pc) {
            if (pc.iceGatheringState === 'complete') return Promise.resolve();
            return new Promise((resolve) => {
                function check() {
                    if (pc.iceGatheringState === 'complete') {
                        pc.removeEventListener('icegatheringstatechange', check); resolve();
                    }
                }
                pc.addEventListener('icegatheringstatechange', check);
            });
        }

        document.getElementById('createOffer').onclick = createOffer;
        document.getElementById('setAnswer').onclick = setAnswer;

        // Input events -> send JSON over dcInput
        function sendEvent(ev) {
            if (!dcInput || dcInput.readyState !== 'open') return;
            if (ev.type === 'contextmenu' || (ev.type === 'keydown' && (ev.ctrlKey || ev.metaKey))) ev.preventDefault();
            const data = { type: ev.type, key: ev.key, keyCode: ev.keyCode, modifiers: [], deltaY: ev.deltaY };
            if (ev.shiftKey) data.modifiers.push('shift');
            if (ev.ctrlKey) data.modifiers.push('ctrl');
            if (ev.altKey) data.modifiers.push('alt');
            if (ev.type.startsWith('mouse') || ev.type === 'wheel' || ev.type === 'contextmenu') {
                if (ev.clientX < offsetX || ev.clientX > offsetX + (serverWidth * scale) || ev.clientY < offsetY || ev.clientY > offsetY + (serverHeight * scale)) return;
                data.x = Math.round((ev.clientX - offsetX) / scale);
                data.y = Math.round((ev.clientY - offsetY) / scale);
            }
            if (ev.type === 'mousedown' || ev.type === 'mouseup' || ev.type === 'contextmenu') {
                data.button = ev.button === 2 ? 'right' : ev.button === 1 ? 'center' : 'left';
            }
            dcInput.send(JSON.stringify(data));
        }
        window.addEventListener('paste', (e) => {
            if (!dcInput || dcInput.readyState !== 'open') return; e.preventDefault();
            const text = e.clipboardData.getData('text/plain');
            dcInput.send(JSON.stringify({ type: 'paste', clipboardText: text }));
        });
        screen.addEventListener('mousemove', sendEvent);
        screen.addEventListener('mousedown', sendEvent);
        screen.addEventListener('mouseup', sendEvent);
        screen.addEventListener('contextmenu', sendEvent);
        screen.addEventListener('wheel', sendEvent);
        window.addEventListener('keydown', sendEvent);
        window.addEventListener('keyup', sendEvent);
    </script>
</body>
</html>
